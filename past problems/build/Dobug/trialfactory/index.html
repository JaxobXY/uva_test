<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Basic Factory Game</title>
<style>
  body { background:#111; color:#eee; font-family:sans-serif; }
  #ui { margin:10px; }
  button { margin-right:5px; }
  #game {
    margin:10px;
    border:1px solid #555;
    image-rendering:pixelated;
  }
</style>
</head>
<body>
<div id="ui">
  Mode:
  <button onclick="setMode('coin')">Coin</button>
  <button onclick="setMode('beltUp')">Belt ↑</button>
  <button onclick="setMode('beltRight')">Belt →</button>
  <button onclick="setMode('beltDown')">Belt ↓</button>
  <button onclick="setMode('beltLeft')">Belt ←</button>
  <button onclick="setMode('output')">Output</button>
  <span style="margin-left:20px">Current: <span id="modeLabel">coin</span></span>
  <span style="margin-left:20px">Score: <span id="score">0</span></span>
</div>

<canvas id="game" width="640" height="480"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const modeLabel = document.getElementById("modeLabel");
const scoreSpan = document.getElementById("score");

const TILE = 32;
const COLS = canvas.width / TILE;
const ROWS = canvas.height / TILE;

let mode = "coin";
let score = 0;

function setMode(m) {
  mode = m;
  modeLabel.textContent = m;
}

// grid: belts & outputs
const grid = [];
for (let y = 0; y < ROWS; y++) {
  grid[y] = [];
  for (let x = 0; x < COLS; x++) {
    grid[y][x] = {
      beltDir: null,   // "up","right","down","left"
      output: false
    };
  }
}

// coins: {x,y,value} in tile coords (x,y integers)
let coins = [];

// mouse placement
canvas.addEventListener("click", e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const x = Math.floor(mx / TILE);
  const y = Math.floor(my / TILE);
  if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return;

  const cell = grid[y][x];

  if (mode === "coin") {
    // place coin of value 1
    coins.push({ x, y, value: 1 });
  } else if (mode === "output") {
    cell.output = true;
  } else if (mode.startsWith("belt")) {
    if (mode === "beltUp") cell.beltDir = "up";
    if (mode === "beltRight") cell.beltDir = "right";
    if (mode === "beltDown") cell.beltDir = "down";
    if (mode === "beltLeft") cell.beltDir = "left";
  }
});

// game loop
function step() {
  // move coins along belts
  const newCoins = [];
  for (const c of coins) {
    let nx = c.x;
    let ny = c.y;
    const cell = grid[c.y][c.x];
    if (cell.beltDir) {
      if (cell.beltDir === "up") ny--;
      if (cell.beltDir === "down") ny++;
      if (cell.beltDir === "left") nx--;
      if (cell.beltDir === "right") nx++;
    }
    // bounds check
    if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) {
      // drop coin if off-grid
      continue;
    }
    // if new cell is output, add to score and don't keep coin
    if (grid[ny][nx].output) {
      score += c.value;
      continue;
    }
    newCoins.push({ x: nx, y: ny, value: c.value });
  }

  // combine coins on same tile
  const map = new Map(); // key "x,y" -> value sum
  for (const c of newCoins) {
    const key = c.x + "," + c.y;
    if (!map.has(key)) map.set(key, 0);
    map.set(key, map.get(key) + c.value);
  }
  coins = [];
  for (const [key, value] of map.entries()) {
    const [sx, sy] = key.split(",").map(Number);
    coins.push({ x: sx, y: sy, value });
  }

  // draw
  draw();
  requestAnimationFrame(step);
}

function draw() {
  ctx.fillStyle = "#222";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // grid lines
  ctx.strokeStyle = "#333";
  for (let x = 0; x <= COLS; x++) {
    ctx.beginPath();
    ctx.moveTo(x * TILE, 0);
    ctx.lineTo(x * TILE, ROWS * TILE);
    ctx.stroke();
  }
  for (let y = 0; y <= ROWS; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * TILE);
    ctx.lineTo(COLS * TILE, y * TILE);
    ctx.stroke();
  }

  // draw belts and outputs
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      const cell = grid[y][x];
      const px = x * TILE;
      const py = y * TILE;

      if (cell.output) {
        ctx.fillStyle = "#004400";
        ctx.fillRect(px+2, py+2, TILE-4, TILE-4);
        ctx.fillStyle = "#0f0";
        ctx.font = "16px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("OUT", px + TILE/2, py + TILE/2);
      }

      if (cell.beltDir) {
        ctx.fillStyle = "#555";
        ctx.fillRect(px+4, py+4, TILE-8, TILE-8);
        ctx.fillStyle = "#ddd";
        ctx.font = "20px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        let ch = "?";
        if (cell.beltDir === "up") ch = "↑";
        if (cell.beltDir === "right") ch = "→";
        if (cell.beltDir === "down") ch = "↓";
        if (cell.beltDir === "left") ch = "←";
        ctx.fillText(ch, px + TILE/2, py + TILE/2);
      }
    }
  }

  // draw coins
  for (const c of coins) {
    const px = c.x * TILE;
    const py = c.y * TILE;
    ctx.fillStyle = "#ccaa00";
    ctx.beginPath();
    ctx.arc(px + TILE/2, py + TILE/2, TILE/2 - 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "#886600";
    ctx.stroke();

    ctx.fillStyle = "#000";
    ctx.font = "16px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(c.value.toString(), px + TILE/2, py + TILE/2);
  }

  scoreSpan.textContent = score;
}

requestAnimationFrame(step);
</script>
</body>
</html>
