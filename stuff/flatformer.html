<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>FLatformer</title>
  <style>
    :root{
      --bg:#111; --panel:#1b1b1b; --panel2:#222; --ink:#fff; --muted:#bbb;
      --btn:#3a3a3a; --btn2:#525252; --accent:#ffffff;
    }
    body { margin: 0; background: var(--bg); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #layout { max-width: 1180px; margin: 0 auto; padding: 10px; }

    #gameRow { display: flex; gap: 12px; align-items: flex-start; justify-content: center; }
    canvas { background: #222; border-radius: 10px; display:block; }

    /* Sidebar inventory */
    #sidebar {
      width: 300px;
      background: var(--panel);
      border-radius: 12px;
      padding: 10px;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.08) inset;
      display: none;
    }
    #sidebarHeader{
      display:flex; align-items:center; justify-content:space-between;
      gap:8px; margin-bottom: 10px;
    }
    #sidebarHeader .title{ font-weight: 700; font-size: 14px; color: var(--ink); letter-spacing: .2px; }
    #selectedTileBadge{
      font-size: 12px; padding: 4px 8px; border-radius: 999px;
      background: var(--panel2); color: var(--muted);
      border: 1px solid rgba(255,255,255,0.08); white-space: nowrap;
    }

    details {
      background: var(--panel2);
      border-radius: 10px;
      padding: 8px 10px;
      margin-bottom: 10px;
      border: 1px solid rgba(255,255,255,0.08);
    }
    summary {
      cursor: pointer;
      font-weight: 650;
      color: var(--ink);
      user-select: none;
      list-style: none;
    }
    summary::-webkit-details-marker { display: none; }
    summary::after{ content:"▾"; float:right; opacity:0.8; }
    details[open] summary::after{ content:"▴"; }

    .invGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      margin-top: 10px;
    }

    .tileBtn{
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.10);
      background: var(--btn);
      color: var(--ink);
      cursor: pointer;
      min-height: 44px;
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      justify-content:center;
      gap:4px;
      text-align:left;
    }
    .tileBtn:hover { background: var(--btn2); }
    .tileBtn.active { outline: 2px solid var(--accent); }
    .tileBtn .k{ font-size: 12px; color: var(--muted); }
    .tileBtn .n{ font-size: 13px; font-weight: 700; }

    #tileDesc{
      margin-top: 10px;
      background: #141414;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 10px;
      padding: 10px;
      min-height: 84px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
      text-align:left;
    }

    #ui { max-width: 920px; margin: 10px auto 0; text-align: center; }
    #menu, #mapBar, #editorUI, #dpad { margin-top: 12px; }

    button.uiBtn{
      padding: 10px 18px;
      font-size: 16px;
      margin: 5px;
      border-radius: 10px;
      border: none;
      background: #444;
      color: #fff;
      cursor: pointer;
      min-width: 80px;
      min-height: 44px;
    }
    button.uiBtn:hover { background: #666; }
    button.uiBtn:active { background: #888; }

    #editorInfo, #mapLabel { font-size: 14px; margin-top: 4px; color: #ccc; }

    #dpad {
      display: grid;
      grid-template-columns: repeat(5, minmax(60px, auto));
      grid-template-rows: repeat(3, minmax(50px, auto));
      gap: 10px;
      justify-content: center;
      margin-top: 12px;
      align-items: center;
    }
    #upBtn    { grid-column: 3; grid-row: 1; }
    #leftBtn  { grid-column: 2; grid-row: 2; }
    #downBtn  { grid-column: 3; grid-row: 3; }
    #rightBtn { grid-column: 4; grid-row: 2; }
    #zoomInBtn  { grid-column: 1; grid-row: 2; }
    #zoomOutBtn { grid-column: 5; grid-row: 2; }

    @media (max-width: 1100px){
      #gameRow{ flex-direction: column; align-items:center; }
      #sidebar{ width: min(720px, 100%); }
      canvas{ width: min(800px, 100%); height:auto; }
    }
  </style>
</head>
<body>
  <div id="layout">
    <div id="gameRow">
      <canvas id="game" width="800" height="450"></canvas>

      <aside id="sidebar">
        <div id="sidebarHeader">
          <div class="title">Inventory</div>
          <div id="selectedTileBadge">Selected: # Block</div>
        </div>

        <details open>
          <summary>Terrain</summary>
          <div class="invGrid">
            <button class="tileBtn" data-tile="." data-name="Air" data-desc="Empty space. Paint this to erase tiles.">
              <div class="n">Air</div><div class="k">.</div>
            </button>
            <button class="tileBtn" data-tile="#" data-name="Block" data-desc="Standard solid block.">
              <div class="n">Block</div><div class="k">#</div>
            </button>
            <button class="tileBtn" data-tile="=" data-name="One-way" data-desc="One-way platform: only collides when landing from above. Never pushes sideways.">
              <div class="n">One-way</div><div class="k">=</div>
            </button>
            <button class="tileBtn" data-tile="I" data-name="Ice" data-desc="Low friction surface. You slide more when standing on it.">
              <div class="n">Ice</div><div class="k">I</div>
            </button>
            <button class="tileBtn" data-tile="B" data-name="Breakable" data-desc="Breaks when hit from below.">
              <div class="n">Breakable</div><div class="k">B</div>
            </button>
          </div>
        </details>

        <details>
          <summary>Conveyors</summary>
          <div class="invGrid">
            <button class="tileBtn" data-tile="C" data-name="Conveyor Right" data-desc="Moves you right while grounded at 2× player speed.">
              <div class="n">Conv →</div><div class="k">C</div>
            </button>
            <button class="tileBtn" data-tile="c" data-name="Conveyor Left" data-desc="Moves you left while grounded at 2× player speed.">
              <div class="n">Conv ←</div><div class="k">c</div>
            </button>
          </div>
        </details>

        <details>
          <summary>Items</summary>
          <div class="invGrid">
            <button class="tileBtn" data-tile="K" data-name="Key" data-desc="Collect to open the matching lock (by ID order).">
              <div class="n">Key</div><div class="k">K</div>
            </button>
            <button class="tileBtn" data-tile="L" data-name="Lock" data-desc="Solid until its matching key is collected.">
              <div class="n">Lock</div><div class="k">L</div>
            </button>
            <button class="tileBtn" data-tile="P" data-name="Portal" data-desc="Paired portals teleport you. Paired by placement order.">
              <div class="n">Portal</div><div class="k">P</div>
            </button>
          </div>
        </details>

        <details>
          <summary>Mechanisms</summary>
          <div class="invGrid">
            <button class="tileBtn" data-tile="J" data-name="Jump Pad" data-desc="Bounces you upward when you land on it.">
              <div class="n">Jump Pad</div><div class="k">J</div>
            </button>
            <button class="tileBtn" data-tile="<" data-name="Left Piston" data-desc="Pushes player left briefly when touched.">
              <div class="n">Piston ←</div><div class="k">&lt;</div>
            </button>
            <button class="tileBtn" data-tile=">" data-name="Right Piston" data-desc="Pushes player right briefly when touched.">
              <div class="n">Piston →</div><div class="k">&gt;</div>
            </button>
            <button class="tileBtn" data-tile="T" data-name="Turret" data-desc="Shoots bullets in its facing direction. Can be placed on map OR glued onto movers/rotators. Editor: click turret then Shift+Arrow sets Left/Right/Up/Down.">
              <div class="n">Turret</div><div class="k">T</div>
            </button>
          </div>
        </details>

        <details>
          <summary>Platforms</summary>
          <div class="invGrid">
            <button class="tileBtn" data-tile="M" data-name="Mover" data-desc="Moving platform anchor. Use G to glue tiles. +/- changes travel distance.">
              <div class="n">Mover</div><div class="k">M</div>
            </button>
            <button class="tileBtn" data-tile="R" data-name="Rotator" data-desc="Rotating platform anchor. Use G to glue tiles. True rotated collision (OBB).">
              <div class="n">Rotator</div><div class="k">R</div>
            </button>
          </div>
        </details>

        <details>
          <summary>Hazards</summary>
          <div class="invGrid">
            <button class="tileBtn" data-tile="S" data-name="Spike" data-desc="Touch = reset. Can be glued to movers/rotators. Checked after collision pushback.">
              <div class="n">Spike</div><div class="k">S</div>
            </button>
          </div>
        </details>

        <details open>
          <summary>Enemies</summary>
          <div class="invGrid">
            <button class="tileBtn" data-tile="E" data-name="Patrol Enemy" data-desc="Walks back and forth. Turns around at walls AND edges. Touch = reset. Enemies reset to spawn when you reset.">
              <div class="n">Patrol</div><div class="k">E</div>
            </button>
            <button class="tileBtn" data-tile="H" data-name="Chase Enemy" data-desc="Chases you within range; otherwise wanders. Touch = reset. Enemies reset to spawn when you reset.">
              <div class="n">Chaser</div><div class="k">H</div>
            </button>
          </div>
        </details>

        <div id="tileDesc">Pick a tile to see its description here.</div>
      </aside>
    </div>

    <div id="ui">
      <div id="menu">
        <button class="uiBtn" id="playBtn">Play</button>
        <button class="uiBtn" id="editorBtn">Editor</button>
        <button class="uiBtn" id="clearBtn">Clear Map</button>
      </div>

      <div id="mapBar">
        <button class="uiBtn" id="prevMapBtn">&lt; Prev Map</button>
        <button class="uiBtn" id="nextMapBtn">Next Map &gt;</button>
        <span id="mapLabel"></span>
      </div>

      <div id="editorUI" style="display:none;">
        <div>
          Editor fly: A/D/←/→ and W/S/↑/↓ (avatar is magenta).<br>
          Click/drag to paint. Sidebar has foldable categories + descriptions.<br>
          Turret: place T (map or glued), click it to select, then <b>Shift + Arrow</b> sets Left/Right/Up/Down.<br>
          Glue: select mover/rotator, press G to toggle glue mode, paint relative to its anchor. Esc clears selection.
        </div>
        <div id="editorInfo"></div>
      </div>

      <div id="dpad">
        <button class="uiBtn" id="zoomInBtn">Zoom +</button>
        <button class="uiBtn" id="upBtn">Jump</button>
        <button class="uiBtn" id="zoomOutBtn">Zoom −</button>
        <button class="uiBtn" id="leftBtn">◀</button>
        <button class="uiBtn" id="downBtn">▼</button>
        <button class="uiBtn" id="rightBtn">▶</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const playBtn    = document.getElementById('playBtn');
  const editorBtn  = document.getElementById('editorBtn');
  const clearBtn   = document.getElementById('clearBtn');
  const editorUI   = document.getElementById('editorUI');
  const editorInfo = document.getElementById('editorInfo');

  const prevMapBtn = document.getElementById('prevMapBtn');
  const nextMapBtn = document.getElementById('nextMapBtn');
  const mapLabel   = document.getElementById('mapLabel');

  const upBtn      = document.getElementById('upBtn');
  const leftBtn    = document.getElementById('leftBtn');
  const downBtn    = document.getElementById('downBtn');
  const rightBtn   = document.getElementById('rightBtn');
  const zoomInBtn  = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');

  const sidebar = document.getElementById('sidebar');
  const selectedTileBadge = document.getElementById('selectedTileBadge');
  const tileDesc = document.getElementById('tileDesc');
  const tileButtons = Array.from(document.querySelectorAll('.tileBtn'));

  let mode = "game";
  const input = { left: false, right: false, jump: false, down: false };

  let cameraX = 0, cameraY = 0, cameraZoom = 1;
  const minZoom = 0.5, maxZoom = 2.5;

  let currentTileType = '#';

  let activeMover   = null;
  let activeRotator = null;
  // { kind:'static', ref: turretObj } OR { kind:'mover'|'rotator', obj: mover/rotator, tile: groupTile }
  let activeTurret  = null;
  let gluePlacement = false;

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function rectsOverlapAABB(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }
  function vecLen(x, y) { return Math.hypot(x, y); }
  function vecNorm(x, y) { const l = vecLen(x, y) || 1; return { x: x / l, y: y / l }; }

  function deepCopyChars(chars){
    return chars.map(row => row.slice());
  }

  function setSelectedTile(tile, name, desc){
    currentTileType = tile;
    tileButtons.forEach(b => b.classList.remove('active'));
    const btn = tileButtons.find(b => b.getAttribute('data-tile') === tile);
    if (btn) btn.classList.add('active');
    selectedTileBadge.textContent = `Selected: ${tile} ${name || ""}`.trim();
    tileDesc.textContent = desc || "—";
  }

  tileButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const t = btn.getAttribute('data-tile');
      setSelectedTile(t, btn.getAttribute('data-name') || "", btn.getAttribute('data-desc') || "");
    });
  });
  setSelectedTile('#', 'Block', 'Standard solid block.');

  function pressButton(btn, key) {
    function handleDown() {
      if (key === 'zoomIn') { if (mode === "game") cameraZoom = Math.min(maxZoom, cameraZoom + 0.1); }
      else if (key === 'zoomOut') { if (mode === "game") cameraZoom = Math.max(minZoom, cameraZoom - 0.1); }
      else input[key] = true;
    }
    function handleUp() { if (key in input) input[key] = false; }
    btn.addEventListener('mousedown', handleDown);
    btn.addEventListener('mouseup', handleUp);
    btn.addEventListener('mouseleave', handleUp);
    btn.addEventListener('touchstart', e => { e.preventDefault(); handleDown(); }, { passive: false });
    btn.addEventListener('touchend',   e => { e.preventDefault(); handleUp(); }, { passive: false });
    btn.addEventListener('touchcancel',e => { e.preventDefault(); handleUp(); }, { passive: false });
  }

  pressButton(leftBtn,   'left');
  pressButton(rightBtn,  'right');
  pressButton(upBtn,     'jump');
  pressButton(downBtn,   'down');
  pressButton(zoomInBtn, 'zoomIn');
  pressButton(zoomOutBtn,'zoomOut');

  function turretDirFromKey(code) {
    if (code === 'ArrowLeft')  return 'l';
    if (code === 'ArrowRight') return 'r';
    if (code === 'ArrowUp')    return 'u';
    if (code === 'ArrowDown')  return 'd';
    return null;
  }
  function turretAngle(dir) {
    if (dir === 'l') return Math.PI;
    if (dir === 'r') return 0;
    if (dir === 'u') return -Math.PI/2;
    if (dir === 'd') return Math.PI/2;
    return 0;
  }
  function getActiveTurretDir() {
    if (!activeTurret) return null;
    if (activeTurret.kind === 'static') return activeTurret.ref.dir;
    return activeTurret.tile.dir || 'r';
  }
  function setActiveTurretDir(d) {
    if (!activeTurret) return;
    if (activeTurret.kind === 'static') activeTurret.ref.dir = d;
    else activeTurret.tile.dir = d;
  }

  addEventListener('keydown', e => {
    // Turret direction setting (Shift+Arrow)
    if (mode === "editor" && activeTurret && e.shiftKey) {
      const d = turretDirFromKey(e.code);
      if (d) { e.preventDefault(); setActiveTurretDir(d); return; }
    }

    if (e.code === 'ArrowLeft' || e.code === 'KeyA')  input.left  = true;
    if (e.code === 'ArrowRight'|| e.code === 'KeyD')  input.right = true;
    if (e.code === 'ArrowDown' || e.code === 'KeyS')  input.down  = true;
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') input.jump = true;

    if (mode === "game") {
      if (e.code === 'KeyQ') cameraZoom = Math.min(maxZoom, cameraZoom + 0.1);
      if (e.code === 'KeyE') cameraZoom = Math.max(minZoom, cameraZoom - 0.1);
    }

    if (mode === "editor") {
      if (e.code === 'KeyG') gluePlacement = !gluePlacement;
      else if (e.key === '+') { if (activeMover) activeMover.pushDist += 10; }
      else if (e.key === '-') { if (activeMover) activeMover.pushDist = Math.max(10, activeMover.pushDist - 10); }
      else if (e.code === 'Escape') {
        activeMover = null; activeRotator = null; activeTurret = null; gluePlacement = false;
      }
    }
  });
  addEventListener('keyup', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA')  input.left  = false;
    if (e.code === 'ArrowRight'|| e.code === 'KeyD')  input.right = false;
    if (e.code === 'ArrowDown' || e.code === 'KeyS')  input.down  = false;
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') input.jump = false;
  });

  // ----------------------------
  // Level / tiles
  // ----------------------------
  const tileSize   = 25;
  const tilesWide  = 128;
  const tilesHigh  = 72;
  const levelWidth  = tilesWide * tileSize;
  const levelHeight = tilesHigh * tileSize;

  function createEmptyMapChars() {
    const arr = [];
    for (let y = 0; y < tilesHigh; y++) {
      const row = [];
      for (let x = 0; x < tilesWide; x++) row.push('.');
      arr.push(row);
    }
    for (let x = 0; x < tilesWide; x++) arr[tilesHigh - 1][x] = '#';
    return arr;
  }

  function buildDefaultLayout1(chars) {
    const g = tilesHigh - 1;

    for (let x = 5; x < 25; x++) chars[g][x] = '#';
    chars[g-1][9] = 'J';

    for (let x = 30; x < 38; x++) chars[g-6][x] = '=';

    for (let x = 40; x < 55; x++) chars[g][x] = 'I';

    for (let x = 58; x < 66; x++) chars[g][x] = 'C';
    for (let x = 66; x < 74; x++) chars[g][x] = 'c';

    for (let x = 15; x < 20; x++) chars[g-8][x] = 'B';

    chars[g-7][15] = 'K';
    for (let y = g - 4; y <= g - 1; y++) chars[y][25] = 'L';
    for (let x = 12; x < 18; x++) chars[g][x] = 'S';
    chars[g - 1][40] = 'P';
    chars[g - 1][100] = 'P';
    chars[g - 1][20] = '>';

    chars[g - 6][55] = 'M';
    chars[g - 10][75] = 'R';

    chars[g - 1][62] = 'E';
    chars[g - 1][72] = 'H';

    // static turret example
    chars[g - 2][68] = 'T';
  }

  function buildDefaultLayout2(chars) {
    const g = tilesHigh - 1;
    for (let x = 5; x < 20; x++) chars[g][x] = '#';
    chars[g - 1][8]  = 'J';
    chars[g - 11][15] = 'K';
    chars[g - 2][30]  = 'L';
    chars[g - 12][8]  = 'P';
    chars[g - 1][60]  = 'P';
    for (let x = 55; x < 70; x++) chars[g - 3][x] = '#';
    for (let x = 80; x < 90; x++) chars[g - 8][x] = '#';
    for (let x = 10; x < 14; x++) chars[g][x] = 'S';
    chars[g - 1][25] = '<';
    chars[g - 7][40] = 'M';
    chars[g - 14][70] = 'R';
    chars[g - 1][10] = 'E';
    chars[g - 6][20] = 'T';
  }

  function makeMap(name, initFn) {
    const designChars = createEmptyMapChars();
    if (initFn) initFn(designChars);

    // IMPORTANT:
    // - designChars = editor/source-of-truth
    // - mapChars    = runtime copy (breakables/keys/locks can change during play)
    const map = {
      name,
      designChars: deepCopyChars(designChars),
      mapChars: deepCopyChars(designChars),

      platforms: [],
      keys: [],
      locks: [],
      jumpPads: [],
      portals: [],
      spikes: [],
      pistons: [],
      movers: [],
      rotators: [],
      enemies: [],
      turrets: [],
      bullets: [] // cleared on rebuild
    };
    rebuildObjectsFromMap(map);
    return map;
  }

  let maps = [];
  let currentMapIndex = 0;
  function currentMap() { return maps[currentMapIndex]; }

  // ----------------------------
  // Rebuild from map (clears bullets)
  // ----------------------------
  function rebuildObjectsFromMap(mapObj) {
    mapObj.platforms = [];
    mapObj.keys = [];
    mapObj.locks = [];
    mapObj.jumpPads = [];
    mapObj.portals = [];
    mapObj.spikes = [];
    mapObj.pistons = [];
    mapObj.movers = [];
    mapObj.rotators = [];
    mapObj.enemies = [];
    mapObj.turrets = [];
    mapObj.bullets = []; // delete bullets when rebuild

    const chars = mapObj.mapChars;

    let keyIdCounter  = 1;
    let lockIdCounter = 1;
    let moverIdCounter = 1;
    let rotIdCounter = 1;
    let enemyIdCounter = 1;

    for (let y = 0; y < tilesHigh; y++) {
      for (let x = 0; x < tilesWide; x++) {
        const ch = chars[y][x];
        const wx = x * tileSize;
        const wy = y * tileSize;

        if (ch === '#' || ch === 'I' || ch === 'B' || ch === '=' || ch === 'c' || ch === 'C') {
          mapObj.platforms.push({
            x: wx, y: wy, w: tileSize, h: tileSize,
            tx: x, ty: y,
            surface: (ch === 'I' ? 'ice' : (ch === 'c' || ch === 'C') ? 'conveyor' : (ch === '=' ? 'oneway' : 'normal')),
            oneWay: (ch === '='),
            breakable: (ch === 'B'),
            conveyDir: (ch === 'C' ? 1 : ch === 'c' ? -1 : 0)
          });
        } else if (ch === 'K') {
          mapObj.keys.push({ id: keyIdCounter++, x: wx, y: wy, w: tileSize, h: tileSize, collected: false });
        } else if (ch === 'L') {
          mapObj.locks.push({ id: lockIdCounter++, x: wx, y: wy, w: tileSize, h: tileSize, open: false });
        } else if (ch === 'J') {
          mapObj.jumpPads.push({ x: wx, y: wy, w: tileSize, h: tileSize, power: -22 });
        } else if (ch === 'P') {
          mapObj.portals.push({ x: wx, y: wy, w: tileSize, h: tileSize, targetIndex: -1, cooldown: 0 });
        } else if (ch === 'S') {
          mapObj.spikes.push({ x: wx, y: wy, w: tileSize, h: tileSize });
        } else if (ch === '<' || ch === '>') {
          mapObj.pistons.push({ x: wx, y: wy, w: tileSize, h: tileSize, dir: (ch === '<' ? -1 : 1) });
        } else if (ch === 'M') {
          mapObj.movers.push({
            id: moverIdCounter++,
            anchorTx: x, anchorTy: y,
            baseX: wx, baseY: wy,
            prevX: wx, prevY: wy,
            curX: wx,  curY: wy,
            phase: 0,
            speed: 0.03,
            pushDist: 100,
            axis: 'x',
            groupTiles: [{ dx: 0, dy: 0, ch: 'M' }],
            turretCD: new Map()
          });
        } else if (ch === 'R') {
          mapObj.rotators.push({
            id: rotIdCounter++,
            anchorTx: x, anchorTy: y,
            baseX: wx, baseY: wy,
            prevX: wx, prevY: wy,
            curX: wx,  curY: wy,
            angle: 0,
            phase: 0,
            speed: 0.03,
            groupTiles: [{ dx: 0, dy: 0, ch: 'R' }],
            turretCD: new Map()
          });
        } else if (ch === 'E' || ch === 'H') {
          mapObj.enemies.push({
            id: enemyIdCounter++,
            type: (ch === 'E' ? 'patrol' : 'chase'),
            spawnX: wx, spawnY: wy,
            x: wx, y: wy,
            w: tileSize * 0.9, h: tileSize * 0.9,
            vx: 0, vy: 0,
            prevX: wx, prevY: wy,
            dir: 1,
            onGround: false,
            think: 0
          });
        } else if (ch === 'T') {
          mapObj.turrets.push({
            anchorTx: x, anchorTy: y,
            x: wx, y: wy, w: tileSize, h: tileSize,
            dir: 'r',
            cooldown: 0,
            fireRate: 45,
            bulletSpeed: 8,
            bulletLife: 220
          });
        }
      }
    }

    // portal pairing
    for (const portal of mapObj.portals) portal.targetIndex = -1;
    if (mapObj.portals.length >= 2) {
      for (let i = 0; i + 1 < mapObj.portals.length; i += 2) {
        const j = i + 1;
        mapObj.portals[i].targetIndex = j;
        mapObj.portals[j].targetIndex = i;
      }
    }
  }

  function initMaps() {
    maps = [
      makeMap("Start", buildDefaultLayout1),
      makeMap("Empty", null),
      makeMap("Vertical", buildDefaultLayout2)
    ];
    currentMapIndex = 0;
    updateMapLabel();
  }
  function updateMapLabel() {
    const m = currentMap();
    mapLabel.textContent = "Map: " + m.name + " (" + (currentMapIndex + 1) + "/" + maps.length + ")";
  }
  initMaps();

  // ----------------------------
  // Player
  // ----------------------------
  const basePlayerWidth  = tileSize;
  const basePlayerHeight = tileSize;
  const crouchHeight     = tileSize * 0.6;

  const player = {
    x: 2 * tileSize,
    y: (tilesHigh - 4) * tileSize,
    w: basePlayerWidth,
    h: basePlayerHeight,
    vx: 0,
    vy: 0,
    prevX: 0,
    prevY: 0,
    onGround: false,
    jumpsUsed: 0,
    maxJumps: 2,
    knockTime: 0,
    standingOn: null,
    groundSurface: 'normal',
    groundConvey: 0
  };

  const gravity = 0.8;
  const moveSpeed = 4;
  const jumpStrength = -14;
  let prevJumpInput = false;

  function resetEnemiesToSpawn(mapObj) {
    for (const e of (mapObj.enemies || [])) {
      e.x = e.spawnX; e.y = e.spawnY;
      e.vx = 0; e.vy = 0;
      e.prevX = e.x; e.prevY = e.y;
      e.onGround = false;
      e.think = 0;
      e.dir = 1;
    }
  }

  function resetPlayer() {
    player.x = 2 * tileSize;
    player.y = (tilesHigh - 4) * tileSize;
    player.vx = 0;
    player.vy = 0;
    player.prevX = player.x;
    player.prevY = player.y;
    player.onGround = false;
    player.jumpsUsed = 0;
    player.knockTime = 0;
    player.w = basePlayerWidth;
    player.h = basePlayerHeight;
    player.standingOn = null;
    player.groundSurface = 'normal';
    player.groundConvey = 0;

    resetEnemiesToSpawn(currentMap());
  }

  // ----------------------------
  // OBB helpers (SAT)
  // ----------------------------
  function getAABBCorners(r) {
    return [
      { x: r.x,       y: r.y },
      { x: r.x+r.w,   y: r.y },
      { x: r.x+r.w,   y: r.y+r.h },
      { x: r.x,       y: r.y+r.h }
    ];
  }
  function makeOBB(cx, cy, hx, hy, angle) {
    const ux = Math.cos(angle), uy = Math.sin(angle);
    const vx = -uy, vy = ux;
    return { cx, cy, hx, hy, ux, uy, vx, vy, angle };
  }
  function getOBBCorners(obb) {
    const { cx, cy, hx, hy, ux, uy, vx, vy } = obb;
    return [
      { x: cx + ux*hx + vx*hy, y: cy + uy*hx + vy*hy },
      { x: cx - ux*hx + vx*hy, y: cy - uy*hx + vy*hy },
      { x: cx - ux*hx - vx*hy, y: cy - uy*hx - vy*hy },
      { x: cx + ux*hx - vx*hy, y: cy + uy*hx - vy*hy }
    ];
  }
  function projectPointsOntoAxis(points, ax, ay) {
    let min = Infinity, max = -Infinity;
    for (const p of points) {
      const d = p.x * ax + p.y * ay;
      if (d < min) min = d;
      if (d > max) max = d;
    }
    return { min, max };
  }
  function satAABBvsOBB(aabb, obb, motionDx = 0, motionDy = 0) {
    const aPts = getAABBCorners(aabb);
    const bPts = getOBBCorners(obb);
    const axes = [
      { x: 1, y: 0 },
      { x: 0, y: 1 },
      { x: obb.ux, y: obb.uy },
      { x: obb.vx, y: obb.vy }
    ];

    let minOverlap = Infinity;
    let bestAxis = null;

    for (const ax0 of axes) {
      const n = vecNorm(ax0.x, ax0.y);
      const ax = n.x, ay = n.y;

      const pa = projectPointsOntoAxis(aPts, ax, ay);
      const pb = projectPointsOntoAxis(bPts, ax, ay);

      const overlap = Math.min(pa.max, pb.max) - Math.max(pa.min, pb.min);
      if (overlap <= 0) return null;

      if (overlap < minOverlap) {
        minOverlap = overlap;
        bestAxis = { x: ax, y: ay };
      }
    }

    const motionDot = motionDx * bestAxis.x + motionDy * bestAxis.y;
    let sign;
    if (Math.abs(motionDot) > 1e-6) sign = motionDot > 0 ? -1 : 1;
    else {
      const aCenter = { x: aabb.x + aabb.w/2, y: aabb.y + aabb.h/2 };
      const bCenter = { x: obb.cx, y: obb.cy };
      const dirX = aCenter.x - bCenter.x;
      const dirY = aCenter.y - bCenter.y;
      sign = (dirX * bestAxis.x + dirY * bestAxis.y) >= 0 ? 1 : -1;
    }

    return { x: bestAxis.x * minOverlap * sign, y: bestAxis.y * minOverlap * sign, depth: minOverlap };
  }

  // ----------------------------
  // Movers / Rotators update
  // ----------------------------
  function updateMovers() {
    const m = currentMap();
    for (const mv of m.movers) {
      mv.prevX = mv.curX; mv.prevY = mv.curY;
      mv.phase += mv.speed;
      const offset = Math.sin(mv.phase) * mv.pushDist;
      if (mv.axis === 'x') { mv.curX = mv.baseX + offset; mv.curY = mv.baseY; }
      else { mv.curX = mv.baseX; mv.curY = mv.baseY + offset; }
    }
  }
  function updateRotators() {
    const m = currentMap();
    for (const rt of m.rotators) {
      rt.prevX = rt.curX; rt.prevY = rt.curY;
      rt.phase += rt.speed;
      rt.angle = rt.phase;
      rt.curX = rt.baseX; rt.curY = rt.baseY;
    }
  }

  // ----------------------------
  // Collision world build
  // ----------------------------
  function isSolidChar(ch) {
    return ch === '#' || ch === 'M' || ch === 'R' || ch === 'L' || ch === 'I' || ch === 'B' || ch === '=' || ch === 'c' || ch === 'C';
  }
  function buildWorldColliders() {
    const m = currentMap();
    const colliders = [];

    for (const p of m.platforms) {
      colliders.push({
        type:'aabb',
        x:p.x, y:p.y, w:p.w, h:p.h,
        dyn:false, dx:0, dy:0,
        platformId:null,
        oneWay: !!p.oneWay,
        surface: p.surface || 'normal',
        conveyDir: p.conveyDir || 0,
        breakable: !!p.breakable,
        tx: p.tx, ty: p.ty
      });
    }

    for (const l of m.locks) {
      if (!l.open) colliders.push({
        type:'aabb',
        x:l.x, y:l.y, w:l.w, h:l.h,
        dyn:false, dx:0, dy:0,
        platformId:null,
        oneWay:false, surface:'normal', conveyDir:0, breakable:false,
        tx:null, ty:null
      });
    }

    for (const mv of m.movers) {
      const dx = mv.curX - mv.prevX;
      const dy = mv.curY - mv.prevY;
      const pid = `M:${mv.id}`;

      for (const t of mv.groupTiles) {
        if (!isSolidChar(t.ch)) continue;

        let surface = 'normal', conveyDir = 0, oneWay = false, breakable = false;
        if (t.ch === 'I') surface = 'ice';
        if (t.ch === 'C') { surface='conveyor'; conveyDir= 1; }
        if (t.ch === 'c') { surface='conveyor'; conveyDir=-1; }
        if (t.ch === '=') { surface='oneway'; oneWay=true; }
        if (t.ch === 'B') { breakable=true; }

        colliders.push({
          type:'aabb',
          x: mv.curX + t.dx*tileSize,
          y: mv.curY + t.dy*tileSize,
          w: tileSize,
          h: tileSize,
          dyn:true, dx, dy,
          platformId: pid,
          oneWay, surface, conveyDir, breakable,
          tx:null, ty:null
        });
      }
    }

    for (const rt of m.rotators) {
      const pid = `R:${rt.id}`;
      const baseX = rt.curX, baseY = rt.curY;
      const rootCx = baseX + tileSize/2, rootCy = baseY + tileSize/2;

      for (const t of rt.groupTiles) {
        if (!isSolidChar(t.ch)) continue;

        const tileCx0 = baseX + t.dx*tileSize + tileSize/2;
        const tileCy0 = baseY + t.dy*tileSize + tileSize/2;
        const dx0 = tileCx0 - rootCx;
        const dy0 = tileCy0 - rootCy;

        const c = Math.cos(rt.angle), s = Math.sin(rt.angle);
        const tileCx = rootCx + dx0*c - dy0*s;
        const tileCy = rootCy + dx0*s + dy0*c;

        colliders.push({
          type:'obb',
          obb: makeOBB(tileCx, tileCy, tileSize/2, tileSize/2, rt.angle),
          dyn:true, dx:0, dy:0,
          platformId: pid
        });
      }
    }

    return colliders;
  }

  function getPlatformDelta(colliders, platformId) {
    for (const c of colliders) if (c.platformId === platformId) return { dx: c.dx || 0, dy: c.dy || 0 };
    return null;
  }

  function findStandingPlatformId(colliders) {
    const feet = { x: player.x, y: player.y + player.h, w: player.w, h: 2 };
    const eps = 2;
    for (const c of colliders) {
      if (!c.platformId) continue;
      if (c.type === 'aabb') {
        const topDist = Math.abs((player.y + player.h) - c.y);
        if (topDist <= eps && rectsOverlapAABB(feet, c)) return c.platformId;
      } else {
        const mtv = satAABBvsOBB(feet, c.obb, 0, 1);
        if (mtv) return c.platformId;
      }
    }
    return null;
  }

  // ----------------------------
  // Axis collision (AABB) + OBB resolve
  // ----------------------------
  function overlapX(a, b) { return Math.min(a.x + a.w, b.x + b.w) - Math.max(a.x, b.x); }
  function overlapY(a, b) { return Math.min(a.y + a.h, b.y + b.h) - Math.max(a.y, b.y); }

  function preserveGroupsAndRebuild(mapObj) {
    const savedMoverGroups = new Map();
    for (const mv of mapObj.movers) savedMoverGroups.set(`M:${mv.anchorTx},${mv.anchorTy}`, mv.groupTiles || [{ dx:0, dy:0, ch:'M' }]);

    const savedRotGroups = new Map();
    for (const rt of mapObj.rotators) savedRotGroups.set(`R:${rt.anchorTx},${rt.anchorTy}`, rt.groupTiles || [{ dx:0, dy:0, ch:'R' }]);

    const savedTurretDirs = new Map();
    for (const t of (mapObj.turrets || [])) savedTurretDirs.set(`T:${t.anchorTx},${t.anchorTy}`, t.dir);

    rebuildObjectsFromMap(mapObj);

    for (const mv of mapObj.movers) {
      const key = `M:${mv.anchorTx},${mv.anchorTy}`;
      if (savedMoverGroups.has(key)) mv.groupTiles = savedMoverGroups.get(key);
      mv.curX = mv.baseX; mv.curY = mv.baseY;
      mv.prevX = mv.baseX; mv.prevY = mv.baseY;
      mv.turretCD = new Map();
    }
    for (const rt of mapObj.rotators) {
      const key = `R:${rt.anchorTx},${rt.anchorTy}`;
      if (savedRotGroups.has(key)) rt.groupTiles = savedRotGroups.get(key);
      rt.curX = rt.baseX; rt.curY = rt.baseY;
      rt.prevX = rt.baseX; rt.prevY = rt.baseY;
      rt.turretCD = new Map();
    }
    for (const t of (mapObj.turrets || [])) {
      const key = `T:${t.anchorTx},${t.anchorTy}`;
      if (savedTurretDirs.has(key)) t.dir = savedTurretDirs.get(key);
    }

    resetEnemiesToSpawn(mapObj);
  }

  // NEW: hard reset runtime from design, then rebuild.
  // This makes Keys/Locks (collected/open) and Breakables come back on any rebuild/reset.
  function resetRuntimeFromDesignAndRebuild(mapObj){
    mapObj.mapChars = deepCopyChars(mapObj.designChars);
    preserveGroupsAndRebuild(mapObj); // recreates keys/locks fresh + restores mover/rotator groups
  }

  function resolveAABBAxis(colliders, axis, appliedDynSet, breakSet, eps = 2) {
    for (let iter = 0; iter < 6; iter++) {
      let any = false;

      for (const c of colliders) {
        if (c.type !== 'aabb') continue;

        // one-way never pushes sideways
        if (axis === 'x' && c.oneWay) continue;

        // apply mover delta once per platform (if overlapping)
        if (c.dyn && (c.dx || c.dy) && c.platformId && c.platformId !== player.standingOn) {
          if (!appliedDynSet.has(c.platformId) && rectsOverlapAABB(player, c)) {
            player.x += c.dx;
            player.y += c.dy;
            appliedDynSet.add(c.platformId);
          }
        }

        if (!rectsOverlapAABB(player, c)) continue;

        if (axis === 'y' && c.oneWay) {
          const wasAbove = (player.prevY + player.h) <= (c.y + eps);
          if (!(player.vy >= 0 && wasAbove)) continue;
        }

        if (axis === 'x') {
          const ox = overlapX(player, c);
          if (ox <= 0) continue;

          let pushLeft;
          if (player.vx !== 0) pushLeft = player.vx > 0;
          else pushLeft = (player.prevX + player.w) <= c.x;

          player.x += (pushLeft ? -ox : ox);
          player.vx = 0;
          any = true;
        } else {
          const oy = overlapY(player, c);
          if (oy <= 0) continue;

          const wasAbove = (player.prevY + player.h) <= (c.y + eps);
          if (player.vy >= 0 && wasAbove) {
            player.y -= oy;
            player.vy = 0;
            player.onGround = true;
            player.jumpsUsed = 0;
          } else {
            player.y += oy;
            if (player.vy < 0) player.vy = 0;

            if (c.breakable && c.tx != null && c.ty != null) breakSet.add(c.tx + "," + c.ty);
          }
          any = true;
        }
      }

      if (!any) break;
    }
  }

  function resolveOBBs(colliders, maxIters = 10) {
    for (let iter = 0; iter < maxIters; iter++) {
      let any = false;
      const motionDx = player.x - player.prevX;
      const motionDy = player.y - player.prevY;

      for (const c of colliders) {
        if (c.type !== 'obb') continue;
        const mtv = satAABBvsOBB(player, c.obb, motionDx, motionDy);
        if (!mtv) continue;

        player.x += mtv.x;
        player.y += mtv.y;

        if (mtv.y < 0 && Math.abs(mtv.y) >= Math.abs(mtv.x) * 0.5) {
          player.onGround = true;
          player.jumpsUsed = 0;
          if (player.vy > 0) player.vy = 0;
        } else {
          if (Math.abs(mtv.x) > Math.abs(mtv.y)) player.vx = 0;
          else player.vy = 0;
        }
        any = true;
      }
      if (!any) break;
    }
  }

  function updateGroundSurface(colliders) {
    player.groundSurface = 'normal';
    player.groundConvey = 0;
    if (!player.onGround) return;

    const feet = { x: player.x, y: player.y + player.h, w: player.w, h: 2 };
    const eps = 2;

    for (const c of colliders) {
      if (c.type !== 'aabb') continue;
      const topDist = Math.abs((player.y + player.h) - c.y);
      if (topDist > eps) continue;
      if (!rectsOverlapAABB(feet, c)) continue;

      if (c.surface === 'ice') player.groundSurface = 'ice';
      else if (c.surface === 'conveyor') { player.groundSurface = 'conveyor'; player.groundConvey = c.conveyDir || 0; }
      else if (c.surface === 'oneway') player.groundSurface = 'oneway';
      return;
    }
  }

  // ----------------------------
  // Enemy AI + collision
  // ----------------------------
  function resolveEnemyAABBAxis(enemy, colliders, axis, eps = 2) {
    for (let iter = 0; iter < 4; iter++) {
      let any = false;

      for (const c of colliders) {
        if (c.type !== 'aabb') continue;

        if (axis === 'x' && c.oneWay) continue;
        if (axis === 'y' && c.oneWay) {
          const wasAbove = (enemy.prevY + enemy.h) <= (c.y + eps);
          if (!(enemy.vy >= 0 && wasAbove)) continue;
        }

        if (!rectsOverlapAABB(enemy, c)) continue;

        if (axis === 'x') {
          const ox = overlapX(enemy, c);
          if (ox <= 0) continue;
          const pushLeft = enemy.vx > 0;
          enemy.x += (pushLeft ? -ox : ox);
          enemy.vx = 0;
          any = true;
        } else {
          const oy = overlapY(enemy, c);
          if (oy <= 0) continue;

          const wasAbove = (enemy.prevY + enemy.h) <= (c.y + eps);
          if (enemy.vy >= 0 && wasAbove) {
            enemy.y -= oy;
            enemy.vy = 0;
            enemy.onGround = true;
          } else {
            enemy.y += oy;
            if (enemy.vy < 0) enemy.vy = 0;
          }
          any = true;
        }
      }

      if (!any) break;
    }
  }

  function enemyHasGroundAhead(enemy, colliders, dir) {
    const px = enemy.x + enemy.w/2 + dir * (enemy.w/2 + 6);
    const probe = { x: px - 3, y: enemy.y + enemy.h + 2, w: 6, h: 6 };

    for (const c of colliders) {
      if (c.type !== 'aabb') continue;
      if (c.oneWay && probe.y > c.y + 6) continue;
      if (rectsOverlapAABB(probe, c)) return true;
    }
    return false;
  }

  function updateEnemies(colliders) {
    const m = currentMap();
    for (const e of m.enemies) {
      e.prevX = e.x; e.prevY = e.y;
      e.onGround = false;

      e.vy += gravity * 0.9;

      if (e.type === 'patrol') {
        const speed = 1.8;
        const desiredVx = e.dir * speed;

        e.vx = desiredVx;
        e.x += e.vx;
        resolveEnemyAABBAxis(e, colliders, 'x');

        if (desiredVx !== 0 && e.vx === 0) e.dir *= -1;

        e.y += e.vy;
        resolveEnemyAABBAxis(e, colliders, 'y');

        if (e.onGround && !enemyHasGroundAhead(e, colliders, e.dir)) e.dir *= -1;
      } else {
        const dx = (player.x + player.w/2) - (e.x + e.w/2);
        const dist = Math.abs(dx);
        const chaseRange = 260;
        const speed = 2.2;

        if (dist < chaseRange) {
          e.vx = dx > 10 ? speed : dx < -10 ? -speed : 0;
          if (e.vx !== 0) e.dir = e.vx > 0 ? 1 : -1;
        } else {
          if (e.think <= 0) {
            e.dir = (Math.random() < 0.5 ? -1 : 1);
            e.think = 40 + Math.floor(Math.random() * 60);
          } else e.think--;
          e.vx = e.dir * 1.1;
        }

        e.x += e.vx;
        resolveEnemyAABBAxis(e, colliders, 'x');

        e.y += e.vy;
        resolveEnemyAABBAxis(e, colliders, 'y');
      }

      if (e.x < 0) { e.x = 0; e.dir = 1; }
      if (e.x + e.w > levelWidth) { e.x = levelWidth - e.w; e.dir = -1; }
      if (e.y + e.h > levelHeight) { e.y = levelHeight - e.h; e.vy = 0; e.onGround = true; }
    }
  }

  // ----------------------------
  // Turrets + bullets (static + glued)
  // ----------------------------
  function turretDirVector(dir) {
    if (dir === 'l') return { x: -1, y: 0 };
    if (dir === 'r') return { x:  1, y: 0 };
    if (dir === 'u') return { x:  0, y: -1 };
    if (dir === 'd') return { x:  0, y: 1 };
    return { x: 1, y: 0 };
  }

  function rotateVec(vx, vy, ang) {
    const c = Math.cos(ang), s = Math.sin(ang);
    return { x: vx*c - vy*s, y: vx*s + vy*c };
  }

  function bulletHitsWorld(b, colliders) {
    const r = { x: b.x, y: b.y, w: b.w, h: b.h };
    for (const c of colliders) {
      if (c.type === 'aabb') {
        if (rectsOverlapAABB(r, c)) return true;
      } else if (c.type === 'obb') {
        if (satAABBvsOBB(r, c.obb, b.vx, b.vy)) return true;
      }
    }
    return false;
  }

  function fireBullet(mapObj, cx, cy, vx, vy, bulletLife) {
    mapObj.bullets.push({
      x: cx - 4,
      y: cy - 4,
      w: 8, h: 8,
      vx, vy,
      life: bulletLife
    });
  }

  function updateTurretsAndBullets(mapObj, colliders) {
    // Static turrets
    for (const t of mapObj.turrets) {
      if (t.cooldown > 0) { t.cooldown--; continue; }
      const d = turretDirVector(t.dir);
      const cx = t.x + t.w/2, cy = t.y + t.h/2;
      fireBullet(mapObj, cx + d.x*(t.w*0.45), cy + d.y*(t.h*0.45), d.x*t.bulletSpeed, d.y*t.bulletSpeed, t.bulletLife);
      t.cooldown = t.fireRate;
    }

    // Glued turrets on movers (no rotation)
    for (const mv of mapObj.movers) {
      if (!mv.turretCD) mv.turretCD = new Map();
      for (const gt of mv.groupTiles) {
        if (gt.ch !== 'T') continue;
        if (!gt.dir) gt.dir = 'r';

        const key = `T:${gt.dx},${gt.dy}`;
        const cd = mv.turretCD.get(key) || 0;
        if (cd > 0) { mv.turretCD.set(key, cd - 1); continue; }

        const d = turretDirVector(gt.dir);
        const tx = mv.curX + gt.dx*tileSize;
        const ty = mv.curY + gt.dy*tileSize;
        const cx = tx + tileSize/2, cy = ty + tileSize/2;

        const speed = 8;
        const life = 220;
        fireBullet(mapObj, cx + d.x*(tileSize*0.45), cy + d.y*(tileSize*0.45), d.x*speed, d.y*speed, life);

        mv.turretCD.set(key, 45);
      }
    }

    // Glued turrets on rotators (direction rotates WITH platform)
    for (const rt of mapObj.rotators) {
      if (!rt.turretCD) rt.turretCD = new Map();

      const baseX = rt.curX, baseY = rt.curY;
      const rootCx = baseX + tileSize/2, rootCy = baseY + tileSize/2;
      const c = Math.cos(rt.angle), s = Math.sin(rt.angle);

      for (const gt of rt.groupTiles) {
        if (gt.ch !== 'T') continue;
        if (!gt.dir) gt.dir = 'r';

        const key = `T:${gt.dx},${gt.dy}`;
        const cd = rt.turretCD.get(key) || 0;
        if (cd > 0) { rt.turretCD.set(key, cd - 1); continue; }

        // tile center rotated into world
        const tileCx0 = baseX + gt.dx*tileSize + tileSize/2;
        const tileCy0 = baseY + gt.dy*tileSize + tileSize/2;
        const dx0 = tileCx0 - rootCx, dy0 = tileCy0 - rootCy;
        const cxW = rootCx + dx0*c - dy0*s;
        const cyW = rootCy + dx0*s + dy0*c;

        // local direction rotated by rt.angle
        const dl = turretDirVector(gt.dir);
        const dw = rotateVec(dl.x, dl.y, rt.angle);

        const speed = 8;
        const life = 220;
        fireBullet(mapObj, cxW + dw.x*(tileSize*0.45), cyW + dw.y*(tileSize*0.45), dw.x*speed, dw.y*speed, life);

        rt.turretCD.set(key, 45);
      }
    }

    // Update bullets
    const next = [];
    for (const b of mapObj.bullets) {
      b.x += b.vx;
      b.y += b.vy;
      b.life--;

      if (b.life <= 0) continue;
      if (b.x < -200 || b.y < -200 || b.x > levelWidth + 200 || b.y > levelHeight + 200) continue;
      if (bulletHitsWorld(b, colliders)) continue;

      if (rectsOverlapAABB(player, b)) { resetPlayer(); continue; }

      next.push(b);
    }
    mapObj.bullets = next;
  }

  // ----------------------------
  // Editor painting + selection (includes glued turret selection)
  // ----------------------------
  let editorMouseDown = false;

  canvas.addEventListener('mousedown', e => {
    if (mode !== "editor") return;
    if (e.button !== 0) return;
    editorMouseDown = true;
    editorClick(e);
  });
  canvas.addEventListener('mouseup', () => { editorMouseDown = false; });
  canvas.addEventListener('mousemove', e => {
    if (mode !== "editor" || !editorMouseDown) return;
    editorClick(e);
  });

  function screenToWorld(mx, my) {
    const viewWidth  = canvas.width  / cameraZoom;
    const viewHeight = canvas.height / cameraZoom;
    const worldX = (mx - canvas.width / 2) / cameraZoom + (cameraX + viewWidth  / 2);
    const worldY = (my - canvas.height / 2) / cameraZoom + (cameraY + viewHeight / 2);
    return { x: worldX, y: worldY };
  }

  function findMoverAtTile(map, tx, ty) {
    return map.movers.find(mv => mv.anchorTx === tx && mv.anchorTy === ty);
  }
  function findRotatorAtTile(map, tx, ty) {
    return map.rotators.find(rt => rt.anchorTx === tx && rt.anchorTy === ty);
  }
  function findStaticTurretAtTile(map, tx, ty) {
    return (map.turrets || []).find(t => t.anchorTx === tx && t.anchorTy === ty);
  }

  function findGluedTurretAtTile(map, tx, ty) {
    for (const mv of map.movers) {
      for (const gt of mv.groupTiles) {
        if (gt.ch !== 'T') continue;
        const atx = mv.anchorTx + gt.dx;
        const aty = mv.anchorTy + gt.dy;
        if (atx === tx && aty === ty) { if (!gt.dir) gt.dir = 'r'; return { kind:'mover', obj: mv, tile: gt }; }
      }
    }
    for (const rt of map.rotators) {
      for (const gt of rt.groupTiles) {
        if (gt.ch !== 'T') continue;
        const atx = rt.anchorTx + gt.dx;
        const aty = rt.anchorTy + gt.dy;
        if (atx === tx && aty === ty) { if (!gt.dir) gt.dir = 'r'; return { kind:'rotator', obj: rt, tile: gt }; }
      }
    }
    return null;
  }

  function editorClick(e) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const worldPos = screenToWorld(mx, my);
    const tx = Math.floor(worldPos.x / tileSize);
    const ty = Math.floor(worldPos.y / tileSize);
    if (tx < 0 || tx >= tilesWide || ty < 0 || ty >= tilesHigh) return;

    const m = currentMap();

    // If not actively gluing, paint + rebuild while preserving groups and turret dirs
    if (!gluePlacement || (!activeMover && !activeRotator)) {
      const savedMoverGroups = new Map();
      for (const mv of m.movers) savedMoverGroups.set(`M:${mv.anchorTx},${mv.anchorTy}`, mv.groupTiles);

      const savedRotGroups = new Map();
      for (const rt of m.rotators) savedRotGroups.set(`R:${rt.anchorTx},${rt.anchorTy}`, rt.groupTiles);

      const savedTurretDirs = new Map();
      for (const t of (m.turrets || [])) savedTurretDirs.set(`T:${t.anchorTx},${t.anchorTy}`, t.dir);

      // EDITOR changes should affect design AND runtime immediately
      m.designChars[ty][tx] = currentTileType;
      m.mapChars[ty][tx] = currentTileType;

      rebuildObjectsFromMap(m); // bullets cleared

      for (const mv of m.movers) {
        const key = `M:${mv.anchorTx},${mv.anchorTy}`;
        if (savedMoverGroups.has(key)) mv.groupTiles = savedMoverGroups.get(key);
      }
      for (const rt of m.rotators) {
        const key = `R:${rt.anchorTx},${rt.anchorTy}`;
        if (savedRotGroups.has(key)) rt.groupTiles = savedRotGroups.get(key);
      }
      for (const t of (m.turrets || [])) {
        const key = `T:${t.anchorTx},${t.anchorTy}`;
        if (savedTurretDirs.has(key)) t.dir = savedTurretDirs.get(key);
      }

      activeMover = null;
      activeRotator = null;
      activeTurret = null;

      // Select what you clicked (mover/rotator anchor, static turret, or glued turret)
      const mv = findMoverAtTile(m, tx, ty);
      const rt = findRotatorAtTile(m, tx, ty);
      const st = findStaticTurretAtTile(m, tx, ty);
      const gt = findGluedTurretAtTile(m, tx, ty);

      if (mv) { activeMover = mv; gluePlacement = true; }
      else if (rt) { activeRotator = rt; gluePlacement = true; }
      else if (st) { activeTurret = { kind:'static', ref: st }; gluePlacement = false; }
      else if (gt) { activeTurret = gt; gluePlacement = false; }

      // If you just placed a turret, select it (static placement)
      if (currentTileType === 'T') {
        const st2 = findStaticTurretAtTile(m, tx, ty);
        if (st2) activeTurret = { kind:'static', ref: st2 };
      }
    } else {
      // Glue paint onto mover/rotator group
      const obj = activeMover || activeRotator;
      const dx = tx - obj.anchorTx;
      const dy = ty - obj.anchorTy;

      if (!obj.groupTiles) obj.groupTiles = [{ dx: 0, dy: 0, ch: (obj === activeMover ? 'M' : 'R') }];

      const existing = obj.groupTiles.find(t => t.dx === dx && t.dy === dy);

      if (currentTileType === '.') {
        if (existing && !(dx === 0 && dy === 0)) obj.groupTiles = obj.groupTiles.filter(t => t !== existing);
      } else {
        if (dx === 0 && dy === 0) obj.groupTiles[0].ch = (obj === activeMover ? 'M' : 'R');
        else if (existing) {
          existing.ch = currentTileType;
          if (existing.ch === 'T' && !existing.dir) existing.dir = 'r';
        } else {
          const nt = { dx, dy, ch: currentTileType };
          if (nt.ch === 'T') nt.dir = 'r';
          obj.groupTiles.push(nt);
        }
      }
    }
  }

  // ----------------------------
  // Mode buttons
  // ----------------------------
  playBtn.onclick = () => {
    mode = "game";
    editorUI.style.display = "none";
    sidebar.style.display = "none";
    gluePlacement = false;
    activeMover = null;
    activeRotator = null;
    activeTurret = null;

    resetPlayer(); // also resets enemies

    // KEY/LOCK/BREAKABLE RESET ON REBUILD:
    // copy design -> runtime, then rebuild objects
    const m = currentMap();
    resetRuntimeFromDesignAndRebuild(m);

    for (const mv of m.movers) mv.phase = 0;
    for (const rt of m.rotators) { rt.phase = 0; rt.angle = 0; }
  };

  editorBtn.onclick = () => {
    mode = "editor";
    editorUI.style.display = "block";
    sidebar.style.display = "block";
    player.vx = 0;
    player.vy = 0;
  };

  clearBtn.onclick = () => {
    const m = currentMap();
    for (let y = 0; y < tilesHigh; y++) for (let x = 0; x < tilesWide; x++) {
      m.designChars[y][x] = '.';
      m.mapChars[y][x] = '.';
    }
    for (let x = 0; x < tilesWide; x++) {
      m.designChars[tilesHigh - 1][x] = '#';
      m.mapChars[tilesHigh - 1][x] = '#';
    }
    rebuildObjectsFromMap(m); // bullets cleared
    activeMover = null;
    activeRotator = null;
    activeTurret = null;
    gluePlacement = false;
  };

  prevMapBtn.onclick = () => {
    currentMapIndex = (currentMapIndex - 1 + maps.length) % maps.length;

    // reset runtime from design whenever you switch maps
    const m = currentMap();
    resetRuntimeFromDesignAndRebuild(m);

    resetPlayer();
    activeMover = null;
    activeRotator = null;
    activeTurret = null;
    gluePlacement = false;
    updateMapLabel();
  };

  nextMapBtn.onclick = () => {
    currentMapIndex = (currentMapIndex + 1) % maps.length;

    const m = currentMap();
    resetRuntimeFromDesignAndRebuild(m);

    resetPlayer();
    activeMover = null;
    activeRotator = null;
    activeTurret = null;
    gluePlacement = false;
    updateMapLabel();
  };

  // ----------------------------
  // Gameplay update
  // ----------------------------
  function updateGame() {
    const m = currentMap();

    updateMovers();
    updateRotators();

    let colliders = buildWorldColliders();

    // Ride mover if standing on it
    if (player.standingOn) {
      const d = getPlatformDelta(colliders, player.standingOn);
      if (d) { player.x += d.dx; player.y += d.dy; }
      else player.standingOn = null;
    }

    if (player.knockTime > 0) player.knockTime--;

    // accel + friction
    if (player.knockTime <= 0) {
      const want = (input.right ? 1 : 0) - (input.left ? 1 : 0);
      const accelGround = 0.9, accelAir = 0.55;

      let frictionG = 0.80;
      if (player.groundSurface === 'ice') frictionG = 0.93;

      const frictionA = 0.93;
      const accel = player.onGround ? accelGround : accelAir;

      if (want !== 0) {
        player.vx += want * accel;
        player.vx = clamp(player.vx, -moveSpeed, moveSpeed);
      } else {
        player.vx *= (player.onGround ? frictionG : frictionA);
        if (Math.abs(player.vx) < 0.03) player.vx = 0;
      }
    }

    // Crouch/stand
    const oldH = player.h;
    if (input.down && player.knockTime <= 0) player.h = crouchHeight;
    else {
      const standRect = { x: player.x, y: player.y - (basePlayerHeight - player.h), w: player.w, h: basePlayerHeight };
      let blocked = false;
      for (const c of colliders) {
        if (c.type === 'aabb') { if (rectsOverlapAABB(standRect, c)) { blocked = true; break; } }
        else { if (satAABBvsOBB(standRect, c.obb, 0, -1)) { blocked = true; break; } }
      }
      if (!blocked) { player.y = standRect.y; player.h = basePlayerHeight; }
    }
    if (player.h < oldH) player.y += (oldH - player.h);

    // Jump edge trigger
    const jumpPressed = input.jump && !prevJumpInput;
    prevJumpInput = input.jump;

    if (jumpPressed && player.knockTime <= 0) {
      if (player.onGround && player.jumpsUsed === 0) {
        player.vy = jumpStrength;
        player.onGround = false;
        player.jumpsUsed = 1;
      } else if (!player.onGround && player.jumpsUsed < player.maxJumps) {
        player.vy = jumpStrength;
        player.jumpsUsed++;
      }
    }

    player.vy += gravity;

    // Save prev for directional collision
    player.prevX = player.x;
    player.prevY = player.y;

    const appliedDynSet = new Set();
    const breakSet = new Set();

    // X then Y
    player.x += player.vx;
    resolveAABBAxis(colliders, 'x', appliedDynSet, breakSet);

    player.onGround = false;
    player.y += player.vy;
    resolveAABBAxis(colliders, 'y', appliedDynSet, breakSet);

    // OBB resolve
    resolveOBBs(colliders, 10);

    // Break breakables (runtime only: DO NOT touch designChars)
    if (breakSet.size > 0) {
      for (const key of breakSet) {
        const [sx, sy] = key.split(',');
        const tx = parseInt(sx, 10), ty = parseInt(sy, 10);
        if (Number.isFinite(tx) && Number.isFinite(ty) && ty>=0 && ty<tilesHigh && tx>=0 && tx<tilesWide) {
          if (m.mapChars[ty][tx] === 'B') m.mapChars[ty][tx] = '.';
        }
      }
      preserveGroupsAndRebuild(m);
      colliders = buildWorldColliders();
    }

    updateGroundSurface(colliders);

    // Conveyor 2x speed
    if (player.onGround && player.groundSurface === 'conveyor' && player.knockTime <= 0) {
      const conveyorSpeed = 2 * moveSpeed;
      player.prevX = player.x;
      player.x += (player.groundConvey || 0) * conveyorSpeed;
      resolveAABBAxis(colliders, 'x', new Set(), new Set());
    }

    // Turrets + bullets AFTER pushback (includes glued turrets)
    updateTurretsAndBullets(m, colliders);

    // Enemies after player stabilized
    updateEnemies(colliders);

    // Hazards AFTER pushback
    // mover-glued spikes/jumps
    for (const mv of m.movers) {
      for (const t of mv.groupTiles) {
        if (t.ch !== 'S' && t.ch !== 'J') continue;
        const tx = mv.curX + t.dx * tileSize;
        const ty = mv.curY + t.dy * tileSize;
        const tileAABB = { x: tx, y: ty, w: tileSize, h: tileSize };

        if (t.ch === 'S') {
          if (rectsOverlapAABB(player, tileAABB)) { resetPlayer(); return; }
        } else {
          const feet = { x: player.x, y: player.y + player.h, w: player.w, h: 2 };
          if (player.vy >= 0 && rectsOverlapAABB(feet, tileAABB)) {
            player.vy = -22;
            player.onGround = false;
            player.jumpsUsed = 1;
          }
        }
      }
    }

    // rotator-glued spikes/jumps
    for (const rt of m.rotators) {
      const baseX = rt.curX, baseY = rt.curY;
      const rootCx = baseX + tileSize/2, rootCy = baseY + tileSize/2;
      const c = Math.cos(rt.angle), s = Math.sin(rt.angle);

      for (const t of rt.groupTiles) {
        if (t.ch !== 'S' && t.ch !== 'J') continue;

        const tileCx0 = baseX + t.dx*tileSize + tileSize/2;
        const tileCy0 = baseY + t.dy*tileSize + tileSize/2;
        const dx0 = tileCx0 - rootCx, dy0 = tileCy0 - rootCy;
        const tileCx = rootCx + dx0*c - dy0*s;
        const tileCy = rootCy + dx0*s + dy0*c;

        const obb = makeOBB(tileCx, tileCy, tileSize/2, tileSize/2, rt.angle);

        if (t.ch === 'S') {
          const mdx = player.x - player.prevX;
          const mdy = player.y - player.prevY;
          if (satAABBvsOBB(player, obb, mdx, mdy)) { resetPlayer(); return; }
        } else {
          const feet = { x: player.x, y: player.y + player.h, w: player.w, h: 2 };
          if (player.vy >= 0 && satAABBvsOBB(feet, obb, 0, 1)) {
            player.vy = -22;
            player.onGround = false;
            player.jumpsUsed = 1;
          }
        }
      }
    }

    // static spikes
    for (const sp of m.spikes) {
      if (rectsOverlapAABB(player, sp)) { resetPlayer(); return; }
    }

    // enemy touch
    for (const e of m.enemies) {
      if (rectsOverlapAABB(player, e)) { resetPlayer(); return; }
    }

    // clamp to world
    if (player.x < 0) player.x = 0;
    if (player.x + player.w > levelWidth) player.x = levelWidth - player.w;
    if (player.y < 0) { player.y = 0; player.vy = 0; }
    if (player.y + player.h > levelHeight) {
      player.y = levelHeight - player.h;
      player.vy = 0;
      player.onGround = true;
      player.jumpsUsed = 0;
    }

    // keys
    for (const key of m.keys) {
      if (!key.collected && rectsOverlapAABB(player, key)) key.collected = true;
    }
    // locks
    for (const lock of m.locks) {
      if (!lock.open) {
        const key1 = m.keys.find(k => k.id === lock.id);
        if (key1 && key1.collected) lock.open = true;
      }
    }

    // jump pads
    for (const pad of m.jumpPads) {
      const feet = { x: player.x, y: player.y + player.h, w: player.w, h: 2 };
      if (rectsOverlapAABB(feet, pad) && player.vy >= 0) {
        player.vy = pad.power;
        player.onGround = false;
        player.jumpsUsed = 1;
      }
    }

    // portals
    for (let i = 0; i < m.portals.length; i++) {
      const portal = m.portals[i];
      if (portal.cooldown > 0) { portal.cooldown--; continue; }
      if (!rectsOverlapAABB(player, portal)) continue;
      if (portal.targetIndex === -1) continue;

      const target = m.portals[portal.targetIndex];
      if (!target) continue;

      player.x = target.x + target.w/2 - player.w/2;
      player.y = target.y - player.h;

      portal.cooldown = 20;
      target.cooldown = 20;
      break;
    }

    // pistons
    const pushTiles = 4;
    const pushSpeed = (pushTiles * tileSize) / 10;
    if (player.knockTime <= 0) {
      for (const p of m.pistons) {
        if (rectsOverlapAABB(player, p)) {
          player.vx = pushSpeed * (p.dir || 1);
          player.knockTime = 10;
          break;
        }
      }
    }

    player.standingOn = player.onGround ? findStandingPlatformId(colliders) : null;
  }

  function updateEditorFly() {
    const flySpeed = 6;
    let vx = 0, vy = 0;
    if (input.left)  vx -= flySpeed;
    if (input.right) vx += flySpeed;
    if (input.jump)  vy -= flySpeed;
    if (input.down)  vy += flySpeed;

    player.x += vx;
    player.y += vy;

    player.x = clamp(player.x, 0, levelWidth - player.w);
    player.y = clamp(player.y, 0, levelHeight - player.h);
  }

  function updateCamera() {
    const viewWidth  = canvas.width  / cameraZoom;
    const viewHeight = canvas.height / cameraZoom;

    cameraX = player.x + player.w/2 - viewWidth/2;
    cameraY = player.y + player.h/2 - viewHeight/2;

    cameraX = clamp(cameraX, 0, Math.max(0, levelWidth - viewWidth));
    cameraY = clamp(cameraY, 0, Math.max(0, levelHeight - viewHeight));
  }

  // ----------------------------
  // Rendering
  // ----------------------------
  function drawTurretAt(tx, ty, dir, extraRotation = 0) {
    const cx = tx + tileSize/2;
    const cy = ty + tileSize/2;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(extraRotation + turretAngle(dir));
    ctx.translate(-cx, -cy);

    ctx.fillStyle = "#888";
    ctx.fillRect(tx, ty, tileSize, tileSize);

    ctx.fillStyle = "#222";
    ctx.fillRect(cx, cy - 4, tileSize * 0.65, 8);

    ctx.restore();
  }

  function drawWorldAndPlayer() {
    const m = currentMap();

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.save();
    const viewWidth  = canvas.width  / cameraZoom;
    const viewHeight = canvas.height / cameraZoom;

    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.scale(cameraZoom, cameraZoom);
    ctx.translate(-(cameraX + viewWidth/2), -(cameraY + viewHeight/2));

    // bg
    ctx.fillStyle = "#222";
    ctx.fillRect(0,0,levelWidth,levelHeight);

    // platforms
    for (const p of m.platforms) {
      if (p.surface === 'ice') ctx.fillStyle = "#77aaff";
      else if (p.surface === 'oneway') ctx.fillStyle = "#aaaaaa";
      else if (p.surface === 'conveyor') ctx.fillStyle = "#66cc66";
      else if (p.breakable) ctx.fillStyle = "#aa8855";
      else ctx.fillStyle = "#555";
      ctx.fillRect(p.x,p.y,p.w,p.h);

      if (p.surface === 'conveyor') {
        ctx.fillStyle = "#111";
        const midY = p.y + p.h/2;
        if (p.conveyDir > 0) {
          ctx.beginPath();
          ctx.moveTo(p.x + p.w - 6, midY);
          ctx.lineTo(p.x + 6, midY - 6);
          ctx.lineTo(p.x + 6, midY + 6);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.moveTo(p.x + 6, midY);
          ctx.lineTo(p.x + p.w - 6, midY - 6);
          ctx.lineTo(p.x + p.w - 6, midY + 6);
          ctx.closePath();
          ctx.fill();
        }
      }
    }

    // locks
    for (const lock of m.locks) {
      if (!lock.open) { ctx.fillStyle="#8844ff"; ctx.fillRect(lock.x,lock.y,lock.w,lock.h); }
    }

    // keys
    for (const key of m.keys) {
      if (!key.collected) { ctx.fillStyle="#ffd700"; ctx.fillRect(key.x+5,key.y+5,key.w-10,key.h-10); }
    }

    // pads
    for (const pad of m.jumpPads) { ctx.fillStyle="#00bfff"; ctx.fillRect(pad.x,pad.y,pad.w,pad.h); }

    // portals
    for (const portal of m.portals) { ctx.fillStyle="#00ff88"; ctx.fillRect(portal.x,portal.y,portal.w,portal.h); }

    // static turrets
    for (const t of m.turrets) drawTurretAt(t.x, t.y, t.dir, 0);

    // bullets
    ctx.fillStyle = "#ffd54a";
    for (const b of m.bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

    // spikes
    ctx.fillStyle="#ff4444";
    for (const s of m.spikes) {
      ctx.beginPath();
      const baseY = s.y + s.h;
      ctx.moveTo(s.x, baseY);
      ctx.lineTo(s.x + s.w/2, s.y);
      ctx.lineTo(s.x + s.w, baseY);
      ctx.closePath();
      ctx.fill();
    }

    // pistons
    for (const p of m.pistons) {
      ctx.fillStyle = p.dir === -1 ? "#ffaa00" : "#00aaff";
      ctx.fillRect(p.x,p.y,p.w,p.h);
      ctx.fillStyle="#000";
      const midY = p.y + p.h/2;
      if (p.dir === -1) {
        ctx.beginPath();
        ctx.moveTo(p.x + 5, midY);
        ctx.lineTo(p.x + p.w - 5, midY - 6);
        ctx.lineTo(p.x + p.w - 5, midY + 6);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.moveTo(p.x + p.w - 5, midY);
        ctx.lineTo(p.x + 5, midY - 6);
        ctx.lineTo(p.x + 5, midY + 6);
        ctx.closePath();
        ctx.fill();
      }
    }

    // movers (draw glued tiles + glued turrets)
    for (const mv of m.movers) {
      for (const t of mv.groupTiles) {
        const tx = mv.curX + t.dx*tileSize;
        const ty = mv.curY + t.dy*tileSize;

        if (t.ch === 'T') {
          if (!t.dir) t.dir = 'r';
          drawTurretAt(tx, ty, t.dir, 0);
          continue;
        }

        let color = "#ff8800";
        if (t.ch === '#') color = "#555";
        else if (t.ch === 'I') color = "#77aaff";
        else if (t.ch === 'B') color = "#aa8855";
        else if (t.ch === '=') color = "#aaaaaa";
        else if (t.ch === 'C' || t.ch === 'c') color = "#66cc66";
        else if (t.ch === 'S') color = "#ff4444";
        else if (t.ch === 'K') color = "#ffd700";
        else if (t.ch === 'L') color = "#8844ff";
        else if (t.ch === 'J') color = "#00bfff";
        else if (t.ch === 'P') color = "#00ff88";
        else if (t.ch === 'M') color = "#ff8800";

        ctx.fillStyle = color;
        if (t.ch === 'S') {
          ctx.beginPath();
          const baseY2 = ty + tileSize;
          ctx.moveTo(tx, baseY2);
          ctx.lineTo(tx + tileSize/2, ty);
          ctx.lineTo(tx + tileSize, baseY2);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.fillRect(tx,ty,tileSize,tileSize);
        }
      }
    }

    // rotators (visual rotation + glued turrets)
    for (const rt of m.rotators) {
      const baseX = rt.curX, baseY = rt.curY;
      const cx = baseX + tileSize/2, cy = baseY + tileSize/2;

      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(rt.angle);
      ctx.translate(-cx,-cy);

      for (const t of rt.groupTiles) {
        const tx = baseX + t.dx*tileSize;
        const ty = baseY + t.dy*tileSize;

        if (t.ch === 'T') {
          if (!t.dir) t.dir = 'r';
          drawTurretAt(tx, ty, t.dir, 0);
          continue;
        }

        let color = "#ff8800";
        if (t.ch === '#') color = "#555";
        else if (t.ch === 'I') color = "#77aaff";
        else if (t.ch === 'B') color = "#aa8855";
        else if (t.ch === '=') color = "#aaaaaa";
        else if (t.ch === 'C' || t.ch === 'c') color = "#66cc66";
        else if (t.ch === 'R') color = "#ff8800";
        else if (t.ch === 'S') color = "#ff4444";
        else if (t.ch === 'K') color = "#ffd700";
        else if (t.ch === 'L') color = "#8844ff";
        else if (t.ch === 'J') color = "#00bfff";
        else if (t.ch === 'P') color = "#00ff88";

        ctx.fillStyle = color;
        if (t.ch === 'S') {
          ctx.beginPath();
          const baseY2 = ty + tileSize;
          ctx.moveTo(tx, baseY2);
          ctx.lineTo(tx + tileSize/2, ty);
          ctx.lineTo(tx + tileSize, baseY2);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.fillRect(tx,ty,tileSize,tileSize);
        }
      }

      ctx.restore();
    }

    // enemies
    for (const e of m.enemies) {
      ctx.fillStyle = (e.type === 'patrol') ? "#ff3355" : "#ffbb33";
      ctx.fillRect(e.x, e.y, e.w, e.h);
      ctx.fillStyle = "#111";
      const eyeX = e.x + (e.dir > 0 ? e.w*0.65 : e.w*0.2);
      ctx.fillRect(eyeX, e.y + e.h*0.25, 3, 3);
    }

    // player
    ctx.fillStyle = (mode === "editor") ? "#ff00ff" : "#0f0";
    ctx.fillRect(player.x,player.y,player.w,player.h);

    ctx.restore();
  }

  // ----------------------------
  // Main loop
  // ----------------------------
  function loop() {
    if (mode === "game") updateGame();
    else updateEditorFly();

    updateCamera();
    drawWorldAndPlayer();

    if (mode === "editor") {
      if (activeMover) {
        editorInfo.textContent = `Mover selected | Dist: ${activeMover.pushDist} | Glue: ${gluePlacement ? "ON" : "OFF"} | Controls: G glue, +/- distance, Esc clear.`;
      } else if (activeRotator) {
        editorInfo.textContent = `Rotator selected | Glue: ${gluePlacement ? "ON" : "OFF"} | Controls: G glue, Esc clear.`;
      } else if (activeTurret) {
        const d = getActiveTurretDir();
        const label = d==='l'?'Left':d==='r'?'Right':d==='u'?'Up':'Down';
        const kind = activeTurret.kind === 'static' ? 'Static' : (activeTurret.kind === 'mover' ? 'Mover-glued' : 'Rotator-glued');
        editorInfo.textContent = `${kind} turret selected | Facing: ${label} | Set with Shift+Arrow.`;
      } else {
        editorInfo.textContent = `Editor fly | Map ${currentMap().name} | Avatar tile (${Math.floor(player.x/tileSize)}, ${Math.floor(player.y/tileSize)})`;
      }
    }

    requestAnimationFrame(loop);
  }

  loop();
})();
</script>
</body>
</html>



